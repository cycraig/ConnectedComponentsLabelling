#include "common_ccl.h"
#include <mpi.h>

/**************ARGUMENT HANDLING****************/
typedef enum {NORMAL_MODE, RANDOM_MODE} image_mode_t;
struct arguments {
    image_mode_t mode;
		char* filename;
		bool bench;
		bool visualise;
		int width;
};
struct arguments parsed_args;

static error_t parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = (struct arguments*)state->input;
    switch (key) {
    	case 'm':
				if (strcmp(arg,"normal") == 0) arguments->mode = NORMAL_MODE;
				else if (strcmp(arg,"random") == 0) arguments->mode = RANDOM_MODE;
				else argp_error(state,"\"%s\" is not a valid parameter for -m",arg);
				break;
    	case 'f':
				if (arg==0) argp_error(state,"-f requires a file.");
				else arguments->filename = arg;
				break;
    	case 'b': arguments->bench = true; arguments->visualise = false; break;
			case 'v': arguments->bench = true; arguments->visualise = false; break;
			case 'w':
				if (atoi(arg) > 0) arguments->width = atoi(arg);
				else argp_error(state,"-w requires an integer larger than 0.");
				break;
    	case ARGP_KEY_ARG: return 0;
			default: return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

void get_args(int argc, char** argv) {
	parsed_args.mode = NORMAL_MODE;
	parsed_args.filename = NULL;
	parsed_args.bench = false;
	parsed_args.visualise = true;
	parsed_args.width = -1;

	const char* argp_version =
	 "CCL image labeller (MPI Implementation) - version 1.0";
	const char* argp_program_bug_address =
	 "craig.bester@students.wits.ac.za|liam.pulles@students.wits.ac.za";
	static char doc[] =
	 "Performs Connected Component Labeling on a binary (but 24 bit) BMP image,\
	 producing a coloured visualisation and coloured output.";
	static struct argp_option options[] = {
	    { "mode", 'm', "normal|random", 0, "Specifies normal or random image mode."
		    " In normal mode, an image is read (See -f) and the computed image is "
				"displayed (if -v true, -b false) and saved. In random mode, an image"
				" with random pixels is generated by the program and the computed image "
				"can be visualised, but is not saved. If random is chosen, -w must be "
				"specified. Default is normal."},
	    { "file", 'f', "<image file>", 0, "Input greyscale 24 bit RGB image. The program "
			  "automatically binarises the image by thresholding. Not neccesary if "
				"-m=random."},
	    { "bench", 'b', 0, 0, "Turn benchmark mode on. If benchmark mode is on: the"
			  " visualisation is turned off, and the output is limited to comma "
				"seperated values to be used for graph generation purposes."},
			{ "visual-off", 'v', 0, 0, "Turn the visualisation off. By default,"
		    " the program will bring up a window to preview the result of the "
				"labeling before saving the image. -b set will set -v."},
			{ "width", 'w', "<int>", 0, "Only required if -m=random. Specifies the width"
		    " (and thus also height, since the generated image wil be square) of the"
				" random image. Must be larger than 0."},
	    { 0 }
	};

	static struct argp argp = { options, parse_opt, 0, doc};
	argp_parse(&argp, argc, argv, 0, 0, &parsed_args);
}
/***********END OF ARGUMENT HANDLING************/

void colourise(int* input, CPUBitmap* output, int width, int height) {
	unsigned char *rgbaPixels = output->get_ptr();
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int label = input[y*width+x];
			if(label == 0) {
				rgbaPixels[y*4*width+4*x]   = 0;
				rgbaPixels[y*4*width+4*x+1] = 0;
				rgbaPixels[y*4*width+4*x+2] = 0;
				rgbaPixels[y*4*width+4*x+3] = 255;
				continue;
			}
			/*rgbaPixels[y*4*width+4*x]   = (input[y*width+x] * 131) % 255;
			rgbaPixels[y*4*width+4*x+1] = (input[y*width+x] * 241) % 255;
			rgbaPixels[y*4*width+4*x+2] = (input[y*width+x] * 251) % 255;*/
            rgbaPixels[y*4*width+4*x]   = (input[y*width+x] * 131) % 177 + (input[y*width+x] * 131) % 78+1;
			rgbaPixels[y*4*width+4*x+1] = (input[y*width+x] * 241) % 56 + (input[y*width+x] * 241) % 199+1;
			rgbaPixels[y*4*width+4*x+2] = (input[y*width+x] * 251) % 237  + (input[y*width+x] * 241) % 18+1;
			rgbaPixels[y*4*width+4*x+3] = 255;
		}
	}
}

void initial_labels(int* blockRows, int rank, int rowsPerRank, int width, int height) {
    // Initial Labelling
    int idx;
	for(int y = 0; y < rowsPerRank && (y+rank*rowsPerRank) < height; y++) {
        for(int x = 0; x < width; x++) {
            idx = y*width+x;
            if(blockRows[idx] > 0) {
		        // +1 to avoid 0 labels
		        blockRows[idx] = idx+1;
            }

        }
    }
}
// Return the root label of pixel p
int find(int p, int* blockRows) {
    //printf("Looking for root label of label %d...\n",p);
    int root = p;
    while (root != blockRows[root-1])
        root = blockRows[root-1];
    //printf("root = %d\n",root);
    while (p != root) {
        int newp = blockRows[p-1];
        blockRows[p-1] = root;
        p = newp;
    }
    return root;
}

// Replace sets containing x and y with their union.
void merge(int a, int b, int* blockRows) {
    int i = find(a,blockRows);
    int j = find(b,blockRows);
    if (i == j) return;
    //printf("(a=%d) %d equivalent to (b=%d) %d\n",a,i,b,j);
    // make smaller label priority
    if (j < i) {
        blockRows[i-1] = j;
    } else {
        blockRows[j-1] = i;
    }
}

#include <unistd.h>

void label(int* blockRows, int rank, int rowsPerRank, int width, int height) {
    /*if(rank == 1) {
        sleep(1);
    }*/
    // initial labelling
    //printf("Initial labelling before:\n");
    //printMatrix(blockRows,width,rowsPerRank);
    initial_labels(blockRows, rank, rowsPerRank, width, height);
    //printf("Initial labelling after:\n");
    //printMatrix(blockRows,width,rowsPerRank);*/
    int offset = rank*rowsPerRank*width;

    // union equivalent regions
	for(int y = 0; y < rowsPerRank && y+rowsPerRank*rank < height; y++) {
		for(int x = 0; x < width; x++) {
			// ignore background pixel
			if(blockRows[y*width+x] > 0) {
			    // check neighbour mask
			    int n=0,nw=0,ne=0,w=0,label=0;
                label = y*width+x+1;
			    if(x > 0) {
				    w = blockRows[y*width+x-1];
                    if(w != 0)
                        merge(label,w,blockRows);
			    }
			    if(y > 0) {
				    n = blockRows[(y-1)*width+x];
                    if(n != 0)
                        merge(label,n,blockRows);
			    }
			    if(y > 0 && x > 0) {
				    nw = blockRows[(y-1)*width+(x-1)];
                    if(nw != 0)
                        merge(label,nw,blockRows);
			    }
			    if(y > 0 && x < (width-1)) {
				    ne = blockRows[(y-1)*width+(x+1)];
                    if(ne != 0)
                        merge(label,ne,blockRows);
			    }
			    //image[y*width+x] = label;
            }
		}
	}

    // local labelling
	for(int y = 0; y < rowsPerRank && y+rowsPerRank*rank < height; y++) {
		for(int x = 0; x < width; x++) {
            if(blockRows[y*width+x] > 0)
    			blockRows[y*width+x] = find(blockRows[y*width+x],blockRows);
		}
	}
    // global labelling
    for(int y = 0; y < rowsPerRank && y+rowsPerRank*rank < height; y++) {
		for(int x = 0; x < width; x++) {
            if(blockRows[y*width+x] > 0)
    			blockRows[y*width+x] += offset;
		}
	}
}

void merge(int* unionImage, int rowsPerRank, int processes, int width, int height) {
    // union equivalent regions
    for(int rank = 1; rank < processes; rank++) {
        // look at row connecting adjacent region
        int y = rank*rowsPerRank;
        //printf("Checking row %d for rank %d\n",y,rank);
        for(int x = 0; x < width; x++) {
			// ignore background pixel
			if(unionImage[y*width+x] > 0) {
			    // check lower row
			    int n=0,nw=0,ne=0,label=0;
                label = y*width+x+1;
			    if(y > 0) {
				    n = unionImage[(y-1)*width+x];
                    if(n != 0)
                        merge(label,n,unionImage);
			    }
			    if(y > 0 && x > 0) {
				    nw = unionImage[(y-1)*width+(x-1)];
                    if(nw != 0)
                        merge(label,nw,unionImage);
			    }
			    if(y > 0 && x < (width-1)) {
				    ne = unionImage[(y-1)*width+(x+1)];
                    if(ne != 0)
                        merge(label,ne,unionImage);
			    }
			    //image[y*width+x] = label;
            }
		}
    }

    // final labelling
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
            if(unionImage[y*width+x] > 0)
    			unionImage[y*width+x] = find(unionImage[y*width+x],unionImage);
		}
	}

}

int main(int argc, char **argv) {
	int rank, processes;

	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &processes);

	int width, height;
	int* dims = new int[2];
	int* binaryImage;
	CPUBitmap *bitmap;
	DataBlock data;
	BMP output;
	if(rank == 0) {
		get_args(argc, argv);

		printf("%s Starting...\n\n", argv[0]);

		//source and results image filenames
		char SampleImageFname[] = "f0001.bmp";
		char *pSampleImageFpath = sdkFindFilePath(SampleImageFname, argv[0]);

		if (pSampleImageFpath == NULL) {
			printf("%s could not locate Sample Image <%s>\nExiting...\n", pSampleImageFpath);
			MPI_Finalize();
			exit(EXIT_FAILURE);
	    }

		BMP input;

		printf("===============================================\n");
		printf("Loading image: %s...\n", pSampleImageFpath);
		bool result = input.ReadFromFile(pSampleImageFpath);
		if (result == false) {
		    printf("\nError: Image file not found or invalid!\n");
			MPI_Finalize();
		    exit(EXIT_FAILURE);
		}
		printf("===============================================\n");

		width = input.TellWidth();
		height = input.TellHeight();
		output.SetSize(width,height);
		output.SetBitDepth(32); // RGBA

		bitmap = new CPUBitmap( width, height, &data );
		data.bitmap = bitmap;
		copyBMPtoBitmap(&input,bitmap);
		binaryImage = new int[width*height];
		bitmapToBinary(bitmap,binaryImage);

		dims[0] = width;
		dims[1] = height;
	}

    // start timing for overhead
    MPI_Barrier(MPI_COMM_WORLD);
    double start_total = MPI_Wtime();

	// broadcast image dimensions (in array to avoid an extra broadcast)
	MPI_Bcast(dims, 2, MPI_INT, 0, MPI_COMM_WORLD);
	width = dims[0];
	height = dims[1];

	// distribute row blocks (scatterv because last rank may have slack)
	int rowsPerRank = (height-1)/processes+1; // ceil
	// calculate counts and offsets
	int* blockRows = new int[rowsPerRank*width];
	int* sendcounts = new int[processes];
	int* displs = new int[processes];
	for(int i = 0; i < processes; i++) {
		if(i < (processes-1)) {
			sendcounts[i] = rowsPerRank*width;
		} else {
			//sendcounts[i] = rowsPerRank*width - (processes*rowsPerRank*width - width*height);
			sendcounts[i] = width*height-(processes-1)*rowsPerRank*width;
		}
		displs[i] = i*rowsPerRank*width;
	}
	MPI_Scatterv(binaryImage, sendcounts, displs, MPI_INT, blockRows, sendcounts[rank], MPI_INT, 0, MPI_COMM_WORLD);

    /*if(rank == 0) {
        printf("Received on rank %d, %d elements over %d rows\n",rank,sendcounts[rank],rowsPerRank);
        printMatrix(blockRows,width,rowsPerRank);
    }
    MPI_Barrier(MPI_COMM_WORLD);
    if(rank == 1) {
        printf("Received on rank %d, %d elements over %d rows:\n",rank,sendcounts[rank],rowsPerRank);
        printMatrix(blockRows,width,rowsPerRank);
    }*/

    if(rank == 0) {
        //printMatrix(binaryImage, width, height);
    }

	if(rank == 0) printf("LABELLING...\n");
    double start = MPI_Wtime();
	label(blockRows, rank, rowsPerRank, width, height);

	// gather row blocks (gatherv because last rank may have slack)
	MPI_Gatherv(blockRows, sendcounts[rank], MPI_INT, binaryImage, sendcounts, displs, MPI_INT, 0, MPI_COMM_WORLD);

    if(rank == 0) {
        //printMatrix(binaryImage, width, height);
    }

    // resolve final labels
    if(rank == 0) {
        //printf("MERGING FINAL IMAGE...\n");
        merge(binaryImage, rowsPerRank, processes, width, height);
    }

    if(rank == 0) {
        //printMatrix(binaryImage, width, height);
    }

    double stop = MPI_Wtime();

    double stop_total = MPI_Wtime();
    if(rank == 0) {
        printf("FINISHED...\n");
        printf("Time elapsed (labelling): %.6f ms\n",(stop-start)*1000.0);
        printf("Time elapsed (total):     %.6f ms\n",(stop_total-start_total)*1000.0);
    }

    if(rank == 0) {
        //Colourise
        printf("Colouring image...\n");
        colourise(binaryImage,bitmap,width,height);
        printf("Done colouring...\n");
    }

	if(rank == 0) {
		//imageToBitmap(binaryImage,&bitmap);
		//binaryToBitmap(binaryImage,bitmap);
		copyBitmapToBMP(bitmap,&output);
		//binaryToBitmap(binaryImage,&bitmap);
		//copyBitmapToBMP(&bitmap,&output);
		//HANDLE_ERROR( cudaMemcpy( bitmap.get_ptr(), ImgSrc, imageSize, cudaMemcpyHostToHost ) );
		//DumpBmpAsGray("out.bmp", ImgSrc, ImgStride, ImgSize);
		output.WriteToFile("out.bmp");
		//bitmap.display_and_exit((void (*)(void*))anim_exit);
		delete[] binaryImage;
	}

	// clean up memory
	delete[] dims;
	delete[] blockRows;
	delete[] sendcounts;
	delete[] displs;

	MPI_Finalize();
}
