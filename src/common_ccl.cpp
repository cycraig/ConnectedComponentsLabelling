#include "common_ccl.h"

/**************ARGUMENT HANDLING****************/

static error_t parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = (struct arguments*)state->input;
    switch (key) {
    	case 'm':
				if (arg==0) argp_error(state,"-m requires a mode.",arg);
				else if (strcmp(arg,"normal") == 0) arguments->mode = NORMAL_MODE;
				else if (strcmp(arg,"random") == 0) arguments->mode = RANDOM_MODE;
				else argp_error(state,"\"%s\" is not a valid parameter for -m.",arg);
				break;
    	case 'f':
				if ((arg==0)||(arg[0]=='\0')) argp_error(state,"-f requires a file.");
				else arguments->filename = arg;
				break;
    	case 'b': arguments->bench = true; arguments->visualise = false; break;
			case 'v': arguments->visualise = true; break;
			case 'w':
				if ((arg==0)||(atoi(arg) <= 0)) argp_error(state,"-w requires an integer larger than 0.");
				else arguments->width = atoi(arg);
				break;
      case 'r': arguments->region_width = atoi(arg);
    	case ARGP_KEY_ARG: return 0;
			default: return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

bool get_args(int argc, char** argv, struct arguments* parsed_args) {
	parsed_args->mode = NORMAL_MODE;
	parsed_args->filename = NULL;
	parsed_args->bench = false;
	parsed_args->visualise = false;
	parsed_args->width = -1;
  parsed_args->region_width = 8;

	const char* argp_program_bug_address =
	 "craig.bester@students.wits.ac.za|liam.pulles@students.wits.ac.za";
	static char doc[] =
	 "Performs Connected Component Labeling on a binary (but 24-bit) BMP image, "
	 "producing a coloured visualisation and a coloured output BMP. The output "
	 "image is saved at <input_filename>_out.bmp (see -f).";
	static struct argp_option options[] = {
	    { "mode", 'm', "normal|random", 0, "Specifies normal or random image mode."
		    " In normal mode, an image is read (See -f) and the computed image is "
				"displayed (if -v true, -b false) and saved. In random mode, an image"
				" with random pixels is generated by the program and the computed image "
				"can be visualised, but is not saved. If random is chosen, -w must be "
				"specified. Default is normal."},
	    { "file", 'f', "<image file>", 0, "Input greyscale 24 bit RGB image. The program "
			  "automatically binarises the image by thresholding. Not neccesary if "
				"-m=random."},
	    { "benchmark", 'b', 0, 0, "Turn benchmark mode on. If benchmark mode is on, the"
			  " visualisation is turned off and the output is limited to comma "
				"seperated values. No image is saved. Used for graph generation purposes."},
			{ "visual", 'v', 0, 0, "Turn the visualisation on. The program will bring up a "
        "window to preview the result of the labeling before saving the image. -b "
        "set will set -v."},
			{ "width", 'w', "<int>", 0, "Only required if -m=random. Specifies the width"
		    " (and thus also height, since the generated image wil be square) of the"
				" random image. Must be larger than 0."},
      { "regionsize", 'r', "<int>", 0, "Specify the width of the square block used"
        "for the CUDA threads. Only affects ccl_gpu*. Default is 8."},
	    { 0 }
	};

	static struct argp argp = { options, parse_opt, 0, doc};
	argp_parse(&argp, argc, argv, 0, 0, parsed_args);

  //Make options consistent
  if (parsed_args->mode == NORMAL_MODE) parsed_args->width = -1;
  else parsed_args->filename == NULL;

	if ((parsed_args->filename == NULL)&&(parsed_args->mode == NORMAL_MODE)) {
		fprintf(stderr,"Must provide -f, with an input BMP (Try --help).\n");
		return false;
	}

  if ((parsed_args->width == -1)&&(parsed_args->mode == RANDOM_MODE)) {
		fprintf(stderr,"Must provide -w, when -m is set to random (Try --help).\n");
		return false;
	}

	return true;
}
/***********END OF ARGUMENT HANDLING************/

bool start(int argc, char** argv,
    int& width, int& height,
    BMP& input,
    arguments& parsed_args) {

      //Suppress EasyBMP warnings, as they go to stdout and are silly.
      SetEasyBMPwarningsOff();

      if (!get_args(argc, argv, &parsed_args)) {
        exit(EXIT_FAILURE);
      }

      fprintf(stderr,"%s Starting...\n\n", argv[0]);
        if (parsed_args.mode == NORMAL_MODE) {
          char *SampleImageFname = parsed_args.filename;

          char *pSampleImageFpath = sdkFindFilePath(SampleImageFname, argv[0]);

          if (pSampleImageFpath == NULL) {
            fprintf(stderr,"%s could not locate Sample Image <%s>\nExiting...\n", pSampleImageFpath);
            return false;
            }

          fprintf(stderr,"===============================================\n");
          fprintf(stderr,"Loading image: %s...\n", pSampleImageFpath);
          bool result = input.ReadFromFile(pSampleImageFpath);
          if (result == false) {
              fprintf(stderr,"\nError: Image file not found or invalid!\n");
              return false;
          }
          fprintf(stderr,"===============================================\n");
        }
        else {
          makeRandomBMP(&input,parsed_args.width,parsed_args.width);
        }
        width = input.TellWidth();
        height = input.TellHeight();

        return true;
}

void finish(int& width, int& height,
    BMP& output,
    CPUBitmap * bitmap,
    int* binaryImage,
    arguments& parsed_args, const char* name) {

    fprintf(stderr,"Colouring image...\n");
    colourise(binaryImage,bitmap,width,height);
    fprintf(stderr,"Done colouring...\n");

    copyBitmapToBMP(bitmap,&output);

    char outname [255];
    if (parsed_args.mode == NORMAL_MODE) sprintf(outname,"%s-%s.bmp",parsed_args.filename,name);
    else sprintf(outname,"random-%dx%d-%s.bmp",width,height,name);
    if (!parsed_args.bench) output.WriteToFile(outname);
    if (parsed_args.visualise) {
      bitmap->display_and_exit((void (*)(void*))anim_exit);
    }
}

void colourise(int* input, CPUBitmap* output, int width, int height) {
	unsigned char *rgbaPixels = output->get_ptr();
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int label = input[y*width+x];
			if(label == 0) {
				rgbaPixels[y*4*width+4*x]   = 0;
				rgbaPixels[y*4*width+4*x+1] = 0;
				rgbaPixels[y*4*width+4*x+2] = 0;
				rgbaPixels[y*4*width+4*x+3] = 255;
				continue;
			}
      rgbaPixels[y*4*width+4*x]   = (input[y*width+x] * 131) % 177 + (input[y*width+x] * 131) % 78+1;
			rgbaPixels[y*4*width+4*x+1] = (input[y*width+x] * 241) % 56 + (input[y*width+x] * 241) % 199+1;
			rgbaPixels[y*4*width+4*x+2] = (input[y*width+x] * 251) % 237  + (input[y*width+x] * 241) % 18+1;
			rgbaPixels[y*4*width+4*x+3] = 255;
		}
	}
}

void makeRandomBMP(BMP* output, int width, int height) {
  output->SetSize(width,height);
  output->SetBitDepth(32); // RGBA
  srand(time(NULL));
  int line_mod = rand()%20;
  for(int y = 0; y < height; y++) {
    for(int x = 0; x < width; x++) {
      //Random binary noise
      int val = (rand()%2)*255;
      //Makes horizontal bars
      if (x%20 == line_mod) val = 0;
      //Connects the horizontal bars every so often
      //if (rand()%600 == line_mod) val = 255-val;
      (*output)(x,y)->Red   = val;
      (*output)(x,y)->Green = val;
      (*output)(x,y)->Blue  = val;
      (*output)(x,y)->Alpha = 255;
    }
  }
}

void copyBMPtoBitmap(BMP* input, CPUBitmap* output) {
	unsigned char *rgbaPixels = output->get_ptr();
	int width = input->TellWidth();
	int height = input->TellHeight();
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			rgbaPixels[y*4*width+4*x]   = (*input)(x,y)->Red;
			rgbaPixels[y*4*width+4*x+1] = (*input)(x,y)->Green;
			rgbaPixels[y*4*width+4*x+2] = (*input)(x,y)->Blue;
			rgbaPixels[y*4*width+4*x+3] = (*input)(x,y)->Alpha;
		}
	}
}

void copyBitmapToBMP(CPUBitmap* input, BMP* output) {
	unsigned char *rgbaPixels = input->get_ptr();
	int width = input->x;
	int height = input->y;
	output->SetSize(width,height);
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			(*output)(x,y)->Red   = rgbaPixels[y*4*width+4*x];
		    (*output)(x,y)->Green = rgbaPixels[y*4*width+4*x+1];
			(*output)(x,y)->Blue  = rgbaPixels[y*4*width+4*x+2];
			(*output)(x,y)->Alpha = rgbaPixels[y*4*width+4*x+3];
		}
	}
}

void bitmapToBinary(CPUBitmap* input, int *output) {
	unsigned char *rgbaPixels = input->get_ptr();
	int width = input->x;
	int height = input->y;
	// output should be of size width*height
	// assuming 4 byte stride for RGBA values
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			unsigned char r = rgbaPixels[y*4*width+4*x];
			unsigned char g = rgbaPixels[y*4*width+4*x+1];
			unsigned char b = rgbaPixels[y*4*width+4*x+2];
			// Thresholding according to: (r+g+b)/3 > 128
			output[y*width+x] = ((r+g+b) > 384); // 1 -> white, 0 -> black
		}
	}
}


void binaryToBitmap(int *input, CPUBitmap* output) {
	// NOTE: scales binary input from [0,1] to [0,255]
	unsigned char *rgbaPixels = output->get_ptr();
	int width = output->x;
	int height = output->y;
	// assuming 4 byte stride for RGBA values
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			// [0,1] -> [0,255]
			rgbaPixels[y*4*width+4*x]   = input[y*width+x]*255;
			rgbaPixels[y*4*width+4*x+1] = input[y*width+x]*255;
			rgbaPixels[y*4*width+4*x+2] = input[y*width+x]*255;
			rgbaPixels[y*4*width+4*x+3] = 255;
		}
	}
}

void imageToBitmap(int *image, CPUBitmap* output) {
	unsigned char *rgbaPixels = output->get_ptr();
	int width = output->x;
	int height = output->y;
	// assuming 4 byte stride for RGBA values
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			rgbaPixels[y*4*width+4*x]   = image[y*width+x];
			rgbaPixels[y*4*width+4*x+1] = image[y*width+x];
			rgbaPixels[y*4*width+4*x+2] = image[y*width+x];
			rgbaPixels[y*4*width+4*x+3] = 255;
		}
	}
}

void getLabelColours(int** labelColours, int maxLabels) {
	for(int i = 1; i <= maxLabels; i++) {
		labelColours[i][0] = i * 131 % 255;
		labelColours[i][1] = i * 241 % 255;
		labelColours[i][2] = i * 251 % 255;
	}
}

void markEquivalent(int** equivalenceMatrix, int a, int b) {
	equivalenceMatrix[a][b] = 1;
	equivalenceMatrix[b][a] = 1;
}

void printMatrix(int* matrix, int width, int height) {
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int val = matrix[y*width+x];
			if(val < 10) {
				printf(" %d ",val);
			} else {
				printf("%d ",val);
			}
		}
		printf("\n");
	}
}

void printMatrix(int** matrix, int width, int height) {
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int val = matrix[y][x];
			if(val < 10) {
				printf(" %d ",val);
			} else {
				printf("%d ",val);
			}
		}
		printf("\n");
	}
}

void printArray(int* array, int size) {
	for(int i = 0; i < size; i++) {
		printf("%d ",array[i]);
	}
	printf("\n");
}

void updateLabelArray(int* labelArray, int** L, int maxLabel) {
	labelArray[0] = 0;
	for(int label = 1; label <= maxLabel; label++) {
		for(int i = 1; i <= maxLabel; i++) {
			if(L[label][i]) {
				labelArray[label] = i;
				break;
			}
		}
	}
	//printf("LABEL ARRAY:\n");
	//printArray(labelArray,maxLabel+1);
}

void resolveEquivalences(int** L, int maxLabel) {
	int n = maxLabel;
	for(int j = 1; j <= n; j++) {
		for(int i = 1; i <= n; i++) {
			if(L[i][j] == 1) {
				for(int k = 1; k <= n; k++) {
					L[i][k] = L[i][k] || L[j][k];
				}
			}
		}
	}
	//printf("EQUIVALENCE MATRIX:\n");
	//printMatrix(L,n+1,n+1);
}

void updateRegion(int* region, int* labelArray, int width, int height) {
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int idx = y*width+x;
			if(region[idx] > 0) {
				region[idx] = labelArray[region[idx]];
			}
		}
	}
}

void printLabels(int* region, int width, int height) {
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			int val = region[y*width+x];
			if(val < 10) {
				printf(" %d ",val);
			} else {
				printf("%d ",val);
			}
		}
		printf("\n");
	}
}

void anim_gpu( DataBlock *d, int ticks ) {
    /*HANDLE_ERROR( cudaEventRecord( d->start, 0 ) );
    dim3    blocks(DIM/16,DIM/16);
    dim3    threads(16,16);
    CPUAnimBitmap  *bitmap = d->bitmap;

    // since tex is global and bound, we have to use a flag to
    // select which is in/out per iteration
    volatile bool dstOut = true;
    for (int i=0; i<90; i++) {
        float   *in, *out;
        if (dstOut) {
            in  = d->dev_inSrc;
            out = d->dev_outSrc;
        } else {
            out = d->dev_inSrc;
            in  = d->dev_outSrc;
        }
        copy_const_kernel<<<blocks,threads>>>( in );
        blend_kernel<<<blocks,threads>>>( out, dstOut );
        dstOut = !dstOut;
    }
    float_to_color<<<blocks,threads>>>( d->output_bitmap,
                                        d->dev_inSrc );

    HANDLE_ERROR( cudaMemcpy( bitmap->get_ptr(),
                              d->output_bitmap,
                              bitmap->image_size(),
                              cudaMemcpyDeviceToHost ) );

    HANDLE_ERROR( cudaEventRecord( d->stop, 0 ) );
    HANDLE_ERROR( cudaEventSynchronize( d->stop ) );
    float   elapsedTime;
    HANDLE_ERROR( cudaEventElapsedTime( &elapsedTime,
                                        d->start, d->stop ) );
    d->totalTime += elapsedTime;
    ++d->frames;
    printf( "Average Time per frame:  %3.1f ms\n",
            d->totalTime/d->frames  );*/
}

// clean up memory allocated on the GPU
void anim_exit( DataBlock *d ) {
    /*
    cudaUnbindTexture( texIn );
    cudaUnbindTexture( texOut );
    cudaUnbindTexture( texConstSrc );
    HANDLE_ERROR( cudaFree( d->dev_inSrc ) );
    HANDLE_ERROR( cudaFree( d->dev_outSrc ) );
    HANDLE_ERROR( cudaFree( d->dev_constSrc ) );

    HANDLE_ERROR( cudaEventDestroy( d->start ) );
    HANDLE_ERROR( cudaEventDestroy( d->stop ) );
    */
}
